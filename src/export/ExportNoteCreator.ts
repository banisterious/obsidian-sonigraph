/**
 * Export Note Creator - Creates markdown notes for exports
 *
 * Generates detailed markdown notes with export information, settings,
 * and links to the exported audio file.
 */

import { App, TFile } from 'obsidian';
import { ExportConfig, ExportResult } from './types';
import { getLogger } from '../logging';

const logger = getLogger('export-note');

/**
 * Creates markdown notes for exports
 */
export class ExportNoteCreator {
    private app: App;
    private pluginVersion: string;

    constructor(app: App, pluginVersion: string = '0.12.1') {
        this.app = app;
        this.pluginVersion = pluginVersion;
    }

    /**
     * Create export note
     */
    async createNote(
        config: ExportConfig,
        result: ExportResult,
        animator: any
    ): Promise<string> {
        try {
            logger.info('export-note', 'Creating export note', {
                filename: config.filename,
                createNote: config.createNote
            });

            // Generate note content
            const noteContent = this.generateNoteContent(config, result, animator);

            // Determine note filename
            const noteName = `${config.filename}-export`;
            const noteFolder = config.exportNoteFolder || config.location;
            const notePath = `${noteFolder}/${noteName}.md`;

            // Check if note already exists
            let finalPath = notePath;
            let counter = 1;
            while (this.app.vault.getAbstractFileByPath(finalPath)) {
                finalPath = `${noteFolder}/${noteName}-${counter}.md`;
                counter++;
            }

            // Create the note
            const file = await this.app.vault.create(finalPath, noteContent);

            logger.info('export-note', 'Export note created', { path: finalPath });
            return finalPath;

        } catch (error) {
            logger.error('export-note', 'Failed to create export note:', error);
            throw error;
        }
    }

    /**
     * Generate note content from template
     */
    private generateNoteContent(
        config: ExportConfig,
        result: ExportResult,
        animator: any
    ): string {
        const timestamp = new Date().toISOString();
        const date = new Date().toLocaleDateString();
        const time = new Date().toLocaleTimeString();

        // Get timeline settings from animator
        const timelineSettings = this.getTimelineSettings(animator);

        // Get audio configuration
        const audioConfig = this.getAudioConfiguration(config);

        // Format metadata
        const metadata = config.metadata || {};

        // Build the note content
        let content = `---
export-date: ${timestamp}
export-format: ${config.format}
export-duration: ${result.duration?.toFixed(2) || 'unknown'}
export-file: "[[${this.getFileName(result.filePath || '')}]]"
tags:
  - sonigraph/export
  - audio/${config.format}
---

# Sonigraph Export - ${config.filename}

## Export Information

**Date:** ${date}
**Time:** ${time}
**Duration:** ${result.duration?.toFixed(2) || 'unknown'} seconds
**Format:** ${config.format.toUpperCase()}
**File Size:** ${this.formatFileSize(result.fileSize || 0)}
**Quality:** ${this.getQualityDescription(config.quality)}

## Audio File

![[${this.getFileName(result.filePath || '')}]]

## Timeline Settings

- **Scope:** ${this.formatScope(config.scope)}
${timelineSettings}

## Audio Configuration

${audioConfig}
`;

        // Add metadata if present
        if (Object.keys(metadata).length > 0) {
            content += `\n## Metadata\n\n`;
            if (metadata.title) content += `- **Title:** ${metadata.title}\n`;
            if (metadata.artist) content += `- **Artist:** ${metadata.artist}\n`;
            if (metadata.album) content += `- **Album:** ${metadata.album}\n`;
            if (metadata.comment) content += `- **Comment:** ${metadata.comment}\n`;
        }

        // Add full settings if requested
        if (config.includeSettingsSummary) {
            content += `\n## Export Settings\n\n\`\`\`json\n${JSON.stringify(this.sanitizeConfig(config), null, 2)}\n\`\`\`\n`;
        }

        // Add footer
        content += `\n---

*Generated by [Sonigraph](obsidian://show-plugin?id=sonigraph) v${this.pluginVersion}*
`;

        return content;
    }

    /**
     * Get timeline settings description
     */
    private getTimelineSettings(animator: any): string {
        if (!animator) {
            return '- **Configuration:** Not available';
        }

        const config = animator.config || {};
        let settings = '';

        if (config.timeWindow) {
            settings += `- **Time Window:** ${config.timeWindow}\n`;
        }

        if (config.granularity) {
            settings += `- **Granularity:** ${config.granularity}\n`;
        }

        if (config.eventSpreadingMode) {
            settings += `- **Event Spreading:** ${config.eventSpreadingMode}\n`;
            settings += `- **Max Event Spacing:** ${config.maxEventSpacing || 'N/A'}s\n`;
            settings += `- **Simultaneous Event Limit:** ${config.simultaneousEventLimit || 'N/A'}\n`;
        }

        if (config.duration) {
            settings += `- **Animation Duration:** ${config.duration}s\n`;
        }

        return settings || '- **Configuration:** Default settings';
    }

    /**
     * Get audio configuration description
     */
    private getAudioConfiguration(config: ExportConfig): string {
        let audioConfig = '';

        // Selected instruments
        if (config.selectedInstruments && config.selectedInstruments.length > 0) {
            audioConfig += `- **Active Instruments:** ${config.selectedInstruments.join(', ')}\n`;
        } else {
            audioConfig += `- **Active Instruments:** All enabled\n`;
        }

        // Audio options
        audioConfig += `- **Continuous Layers:** ${config.includeContinuousLayers ? 'Yes' : 'No'}\n`;
        audioConfig += `- **Master Volume Applied:** ${config.applyMasterVolume ? 'Yes' : 'No'}\n`;
        audioConfig += `- **Effects Applied:** ${config.applyEffects ? 'Yes' : 'No'}\n`;
        audioConfig += `- **Spatial Audio:** ${config.preserveSpatialAudio ? 'Yes' : 'No'}\n`;

        // Rendering method
        audioConfig += `- **Rendering Method:** ${config.renderingMethod}\n`;

        return audioConfig;
    }

    /**
     * Format export scope for display
     */
    private formatScope(scope: string): string {
        switch (scope) {
            case 'full-timeline':
                return 'Full Timeline Animation';
            case 'custom-range':
                return 'Custom Time Range';
            case 'static-graph':
                return 'Current Static Graph';
            case 'selected-nodes':
                return 'Selected Nodes Only';
            default:
                return scope;
        }
    }

    /**
     * Get quality description
     */
    private getQualityDescription(quality: any): string {
        if (!quality) return 'Unknown';

        if (quality.sampleRate && quality.bitDepth) {
            // WAV format
            return `${quality.sampleRate / 1000}kHz, ${quality.bitDepth}-bit`;
        } else if (quality.sampleRate && quality.bitRate) {
            // MP3 format
            return `${quality.sampleRate / 1000}kHz, ${quality.bitRate}kbps`;
        }

        return 'Custom';
    }

    /**
     * Format file size
     */
    private formatFileSize(bytes: number): string {
        if (bytes < 1024) return `${bytes} B`;
        if (bytes < 1024 * 1024) return `${(bytes / 1024).toFixed(1)} KB`;
        return `${(bytes / (1024 * 1024)).toFixed(1)} MB`;
    }

    /**
     * Get filename from path
     */
    private getFileName(filePath: string): string {
        return filePath.split('/').pop() || filePath;
    }

    /**
     * Sanitize config for JSON output (remove functions, circular refs)
     */
    private sanitizeConfig(config: ExportConfig): any {
        return {
            scope: config.scope,
            format: config.format,
            quality: config.quality,
            locationType: config.locationType,
            location: config.location,
            filename: config.filename,
            includeContinuousLayers: config.includeContinuousLayers,
            applyMasterVolume: config.applyMasterVolume,
            applyEffects: config.applyEffects,
            preserveSpatialAudio: config.preserveSpatialAudio,
            renderingMethod: config.renderingMethod,
            metadata: config.metadata
        };
    }
}
