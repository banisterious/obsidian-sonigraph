/**
 * ReportGenerator - Flexible test report generation and export
 * 
 * Generates test reports in multiple formats optimized for different use cases:
 * - Markdown: For Obsidian vault notes
 * - JSON: For data analysis and sharing with developers
 * - CSV: For spreadsheet analysis
 */

import { App } from 'obsidian';
import { TestResults, PerformanceMetrics } from './MetricsCollector';

export class ReportGenerator {
    constructor(private app: App) {}

    /**
     * Generate test report in specified format
     */
    async generateReport(
        results: TestResults, 
        format: 'markdown' | 'json' | 'csv'
    ): Promise<string> {
        switch (format) {
            case 'markdown':
                return this.generateMarkdownReport(results);
            case 'json':
                return this.generateJSONReport(results);
            case 'csv':
                return this.generateCSVReport(results);
            default:
                throw new Error(`Unsupported format: ${format}`);
        }
    }

    /**
     * Generate Markdown report for Obsidian vault
     */
    private generateMarkdownReport(results: TestResults): string {
        const timestamp = new Date(results.timestamp).toLocaleString();
        
        return `# Audio Engine Test Results

**Test Date:** ${timestamp}
**Total Duration:** ${results.duration}ms

## Summary

- **Tests Run:** ${results.testsRun}
- **Passed:** ${results.passed} âœ…
- **Failed:** ${results.failed} âŒ
- **Success Rate:** ${((results.passed / results.testsRun) * 100).toFixed(1)}%

## System Information

- **Platform:** ${results.systemInfo.platform}
- **Audio Sample Rate:** ${results.systemInfo.audioContext.sampleRate}Hz
- **Audio Context State:** ${results.systemInfo.audioContext.state}
${results.systemInfo.audioContext.baseLatency ? `- **Base Latency:** ${(results.systemInfo.audioContext.baseLatency * 1000).toFixed(1)}ms` : ''}
${results.systemInfo.memory.jsHeapSizeLimit ? `- **Heap Size Limit:** ${(results.systemInfo.memory.jsHeapSizeLimit / 1024 / 1024).toFixed(1)}MB` : ''}

## Performance Metrics

### Overall Performance
- **Average Memory Usage:** ${(results.overallMetrics.averageMetrics.memory.heapUsed / 1024 / 1024).toFixed(1)}MB
- **Peak Memory Usage:** ${(results.overallMetrics.peakMetrics.memory.heapUsed / 1024 / 1024).toFixed(1)}MB
- **Average CPU Usage:** ${results.overallMetrics.averageMetrics.audio.cpuUsage.toFixed(1)}%
- **Peak CPU Usage:** ${results.overallMetrics.peakMetrics.audio.cpuUsage.toFixed(1)}%
- **Average Latency:** ${results.overallMetrics.averageMetrics.audio.latency.toFixed(1)}ms
- **Peak Latency:** ${results.overallMetrics.peakMetrics.audio.latency.toFixed(1)}ms

### Performance Trends
- **Memory Growth:** ${this.formatTrend(results.overallMetrics.trends.memoryGrowth)}
- **CPU Trend:** ${this.formatTrend(results.overallMetrics.trends.cpuTrend)}
- **Latency Stability:** ${this.formatStability(results.overallMetrics.trends.latencyStability)}

## Detailed Test Results

${results.testDetails.map(test => this.formatTestMarkdown(test)).join('\n\n')}

## Recommendations

${this.generateMarkdownRecommendations(results)}

## Data Export

\`\`\`json
${JSON.stringify(this.getExportableData(results), null, 2)}
\`\`\`

---

*Generated by Obsidian Sonigraph Plugin Test Suite*
*Share this data by copying the JSON block above*`;
    }

    /**
     * Generate JSON report for data analysis
     */
    private generateJSONReport(results: TestResults): string {
        const exportData = {
            metadata: {
                exportFormat: 'json',
                exportTime: new Date().toISOString(),
                pluginVersion: '1.0.0', // Should be read from manifest
                testSuiteVersion: '1.0.0'
            },
            testResults: results,
            exportableData: this.getExportableData(results),
            analysisReady: true
        };

        return JSON.stringify(exportData, null, 2);
    }

    /**
     * Generate CSV report for spreadsheet analysis
     */
    private generateCSVReport(results: TestResults): string {
        const headers = [
            'Test Name',
            'Status',
            'Duration (ms)',
            'Memory Used (MB)',
            'CPU Usage (%)',
            'Latency (ms)',
            'Active Voices',
            'Error'
        ];

        const rows = results.testDetails.map(test => [
            test.name,
            test.passed ? 'PASS' : 'FAIL',
            test.duration.toString(),
            test.metrics ? (test.metrics.memory.heapUsed / 1024 / 1024).toFixed(1) : '',
            test.metrics ? test.metrics.audio.cpuUsage.toFixed(1) : '',
            test.metrics ? test.metrics.audio.latency.toFixed(1) : '',
            test.metrics ? test.metrics.audio.activeVoices.toString() : '',
            test.error || ''
        ]);

        return [headers, ...rows]
            .map(row => row.map(cell => `"${cell.replace(/"/g, '""')}"`).join(','))
            .join('\n');
    }

    /**
     * Format individual test for Markdown
     */
    private formatTestMarkdown(test: any): string {
        const status = test.passed ? 'âœ… PASS' : 'âŒ FAIL';
        const duration = `${test.duration}ms`;
        
        let content = `### ${test.name} ${status}
**Duration:** ${duration}`;

        if (test.metrics) {
            content += `
**Performance:**
- Memory: ${(test.metrics.memory.heapUsed / 1024 / 1024).toFixed(1)}MB
- CPU: ${test.metrics.audio.cpuUsage.toFixed(1)}%
- Latency: ${test.metrics.audio.latency.toFixed(1)}ms
- Active Voices: ${test.metrics.audio.activeVoices}`;
        }

        if (!test.passed && test.error) {
            content += `
**Error:** \`${test.error}\``;
        }

        return content;
    }

    /**
     * Generate recommendations section for Markdown
     */
    private generateMarkdownRecommendations(results: TestResults): string {
        const recommendations: string[] = [];

        // Performance recommendations
        if (results.overallMetrics.peakMetrics.memory.heapUsed > 100 * 1024 * 1024) {
            recommendations.push('ðŸ”¸ **High Memory Usage:** Peak memory usage exceeded 100MB. Consider optimizing instrument caching and cleanup.');
        }

        if (results.overallMetrics.peakMetrics.audio.cpuUsage > 80) {
            recommendations.push('ðŸ”¸ **High CPU Usage:** Peak CPU usage exceeded 80%. Consider reducing simultaneous voices or effect complexity.');
        }

        if (results.overallMetrics.peakMetrics.audio.latency > 20) {
            recommendations.push('ðŸ”¸ **High Latency:** Audio latency exceeded 20ms. Consider increasing buffer size or optimizing processing chain.');
        }

        // Test failure recommendations
        if (results.failed > 0) {
            recommendations.push('ðŸ”¸ **Test Failures:** Some tests failed. Review the detailed results above and address any errors.');
        }

        // Performance trend recommendations
        if (results.overallMetrics.trends.memoryGrowth > 0.1) {
            recommendations.push('ðŸ”¸ **Memory Growth:** Significant memory growth detected. Check for memory leaks or inefficient caching.');
        }

        if (recommendations.length === 0) {
            recommendations.push('âœ… **All Good:** No significant issues detected in this test run.');
        }

        return recommendations.map(rec => `- ${rec}`).join('\n');
    }

    /**
     * Get data optimized for external sharing and analysis
     */
    private getExportableData(results: TestResults): any {
        return {
            summary: {
                testsRun: results.testsRun,
                passed: results.passed,
                failed: results.failed,
                successRate: (results.passed / results.testsRun) * 100,
                duration: results.duration,
                timestamp: results.timestamp
            },
            systemInfo: {
                platform: results.systemInfo.platform,
                audioSampleRate: results.systemInfo.audioContext.sampleRate,
                audioState: results.systemInfo.audioContext.state,
                baseLatency: results.systemInfo.audioContext.baseLatency,
                outputLatency: results.systemInfo.audioContext.outputLatency,
                heapSizeLimit: results.systemInfo.memory.jsHeapSizeLimit
            },
            performance: {
                memory: {
                    average: Math.round(results.overallMetrics.averageMetrics.memory.heapUsed / 1024 / 1024 * 10) / 10,
                    peak: Math.round(results.overallMetrics.peakMetrics.memory.heapUsed / 1024 / 1024 * 10) / 10,
                    growth: Math.round(results.overallMetrics.trends.memoryGrowth * 100) / 100
                },
                cpu: {
                    average: Math.round(results.overallMetrics.averageMetrics.audio.cpuUsage * 10) / 10,
                    peak: Math.round(results.overallMetrics.peakMetrics.audio.cpuUsage * 10) / 10,
                    trend: Math.round(results.overallMetrics.trends.cpuTrend * 100) / 100
                },
                latency: {
                    average: Math.round(results.overallMetrics.averageMetrics.audio.latency * 10) / 10,
                    peak: Math.round(results.overallMetrics.peakMetrics.audio.latency * 10) / 10,
                    stability: Math.round(results.overallMetrics.trends.latencyStability * 100) / 100
                }
            },
            testDetails: results.testDetails.map(test => ({
                name: test.name,
                passed: test.passed,
                duration: test.duration,
                error: test.error,
                metrics: test.metrics ? {
                    memoryMB: Math.round(test.metrics.memory.heapUsed / 1024 / 1024 * 10) / 10,
                    cpuPercent: Math.round(test.metrics.audio.cpuUsage * 10) / 10,
                    latencyMs: Math.round(test.metrics.audio.latency * 10) / 10,
                    activeVoices: test.metrics.audio.activeVoices
                } : null
            })),
            recommendations: this.generateRecommendationsList(results)
        };
    }

    /**
     * Generate list of actionable recommendations
     */
    private generateRecommendationsList(results: TestResults): string[] {
        const recommendations: string[] = [];

        if (results.failed > 0) {
            recommendations.push('Review and fix failing tests');
        }

        if (results.overallMetrics.peakMetrics.memory.heapUsed > 100 * 1024 * 1024) {
            recommendations.push('Optimize memory usage - consider reducing cache size');
        }

        if (results.overallMetrics.peakMetrics.audio.cpuUsage > 80) {
            recommendations.push('Reduce CPU load - consider lowering voice count or effect complexity');
        }

        if (results.overallMetrics.peakMetrics.audio.latency > 20) {
            recommendations.push('Improve audio latency - consider increasing buffer size');
        }

        if (results.overallMetrics.trends.memoryGrowth > 0.1) {
            recommendations.push('Investigate potential memory leaks');
        }

        return recommendations;
    }

    /**
     * Format trend value for display
     */
    private formatTrend(value: number): string {
        if (value > 0.1) return 'ðŸ“ˆ Increasing';
        if (value < -0.1) return 'ðŸ“‰ Decreasing';
        return 'âž¡ï¸ Stable';
    }

    /**
     * Format stability value for display
     */
    private formatStability(value: number): string {
        if (value > 0.9) return 'ðŸŸ¢ Stable';
        if (value > 0.7) return 'ðŸŸ¡ Moderate';
        return 'ðŸ”´ Unstable';
    }
}